<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">

    <title>Some Advice for CS Freshmen | Not So Null</title>

    <link rel="canonical" href="http://blog.pawandubey.com/advice-for-cs-freshmen/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="http://blog.pawandubey.com/assets/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="http://blog.pawandubey.com/assets/css/clean-blog.css">

	  <!--Google Plus-->
	  <link rel="author" >

    <!-- Custom Fonts -->
    <link href='http://fonts.googleapis.com/css?family=Raleway:800,400,300,600,700|Inconsolata' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    
    <!--Syntax Highlighting-->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/railscasts.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/highlight.min.js"></script>

    <!--FontAwesome-->
    <script src="https://use.fontawesome.com/928161fc5d.js"></script>

    <!--MathJax-->
    <script type="text/javascript" async
            src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
    </script>

    <!--GA-->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-82404247-1', 'auto');
      ga('send', 'pageview');

    </script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>


<body>

<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://blog.pawandubey.com/">Not So Null</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="http://blog.pawandubey.com/">Home</a>
                </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


<!-- Post Header -->


<header class="intro-header">


    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Some Advice for CS Freshmen</h1>                    
                    <span class="meta"><i class="fa fa-calendar"></i> Aug 6 2016</span>                    
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

				<blockquote><p>If you don't really care about my rationale for writing this whole thing, you can jump straight to the <a href="#list">list by clicking here.</a></p>
</blockquote>
<h2>Why should I care?</h2>
<p>As I have grown older, I have realized that no amount of experience is a substitute for good advice from others. This is because of two reasons. The first reason is that no matter how much experience you accumulate, there will always be somebody with more experience than you. You can't overtake time and people who have started earlier simply won that race by being early. This is not a bad thing. By being early, they have made mistakes that you don't have to make if you take their advice. This is a particularly advantageous situation as you get to learn from mistakes without ever making them yourself.</p>
<p>The second reason is that people are generally good and they want you to grow. This is obviously a deeply personal opinion of mine rather than a scientific fact, but it has helped me navigate life with some amount of success, so I will continue to preach it with impunity. This second reason is also more important than the first, since if people did not <em>want</em> to share their experience with you in the first place, the aforementioned first reason is rendered moot.</p>
<p>This is not to mean that <em>experience</em> itself is not sufficient to be successful. On the contrary, the learnings from your experience will take you further than any other factor in your career. The only problem with experience is that it comes at the speed of time, which is insufficient more often than not. Good advice is not unlike a wormhole through time which lets you see a glimpse of the future.</p>
<p>I have benefitted many times from the good advice of others, and not always from people I knew personally. There is a lot of good advice floating around on the interwebs. They can be found in obscure forums and newsboards written by people who twenty years ago were already doing <em>that</em> thing you think is cool now. For me, these were the people who were creating in memory file systems in pure assembly in their spare time and posting about it on some *nix enthusiast forum. Although I was not old enough to be present for the event at the time, but it was one such univeristy student who created a kernel in his spare time sometime in the nineties and posted about it nonchalantly on a newsgroup. But I am sure you have already heard <a href="https://www.cs.cmu.edu/~awb/linux.history.html">that story</a>.</p>
<p><img src="/images/gandalf.png" alt="You don&apos;t need to be Gandalf" />
<center><small>You don't always need Gandalf</small></center></p>
<p>The type of advice I am talking about is not necessarily the life changing monologues that you hear from men with great white beards. Even the little ones count. One of the earliest advices that stuck with me for good was about how good programmers should understand recursion. This was in a blog post by Joel Spolsky in which he was berating the current state of computer science education at universities which promoted easier to learn languages like Python and Java over more <em>close to the metal</em> approach of teaching with hard C. There were a lot of other things said in that blog post but I took that one point and internalized it for some reason. I suspect it was because I had <em>never</em> heard of recursion before that point of time and the word seemed cool, but I like to believe that I had an epiphany. It lead me to a week long quest of learning how to write recursive programs, which I remember proved much more difficult than I thought it would be. But that was a time when YouTube still had only a few thousand videos, internet was rare and expensive and not everybody and their dog were writing recursion tutorials on their shitty blog. I took whatever I could and I believe that the ability to think recursively even before I took any kind of programming course made me a better programmer. There are other little things like this, like knowing how C style strings work and why <a href="https://dtobi.wordpress.com/2011/02/05/some-words-on-malloc-and-memset/"><code>malloc</code> is so evil</a>.</p>
<p>This is why when people ask me about advice related to college and computer science, I don't generally hold back from giving them the small details. And people ask me about this stuff more often than I'd have imagined they would. I am just a college senior, after all, how much could I possibly know to help anybody? But I have learned that this is a wrong approach to take towards life. I have learnt many a things from my juniors over the years. This has lead me to conclude that smartness is not a linear function of age. This is related to how experience is at most times insufficient, even though valuable. Smart people take smart decisions from an early age and can always teach most other people a thing or two. This is not to imply that people asking me for advice proves that I am <em>necessarily</em> smart. But it does suggest that most people find some value in things I have to say and that gives me enough reason to continue doing it. Like I said, most people are inherently good and would like to see others grow. I certainly do.</p>
<p>The problem comes with repeating myself. There is generally a lot of overlap in things I have to tell prospective CS grads. And right from the time I discovered that <em>one could repeat things in GW Basic</em> and had my mind blown, I have had a huge aversion to repeating myself. I mean, we invented computers to do that exact same thing, it makes no sense to be a computer science major and <em>not</em> use computers for their original intended purpose. So I decided to compile whatever worthwhile things I might have to say to some advice seeker and be done with it once and for all.</p>
<p>This, of course, was easier said than done. One has to first of all find the <em>time</em> to do all this. I mean, I can hardly find time to study my own course materials, how do you imagine I can sit and compile all my thoughts into a coherent document? Moreover, writing is hard. I mean, don't take me wrong, it remains a thoroughly enjoyable exercise for me. But writing is hard because of the high standards I have set for myself from my constant berating of poorly written pieces. I can surely not produce a poorly written document after complaining so much about the falling standards of long form writing because of these nine reasons, and number 3 <em>will</em> surprise you!</p>
<p>This idea had been sitting in my drafts folder for the longer part of the last year till a bout of dengue forced me to just be done with it. Being sick really does alienate you of all your excuses for not doing something as lazy as writing. At first I had the idea of gathering advice from all the smart people in CS I know. This sort of compilation of thoughts seemed to be a better thing in every way than a monologue of my own thoughts. However, compilations introduce complications. It becomes almost impossible to make it coherent because before you know, a new opinion has started. And then there might be conflicts of opinion. A person with a 9+ CGPA is almost certainly going to have a different view of academic achievements from a person with a 6 point something. This becomes difficult to moderate when I respect both the people in question. So I chucked that thought and decided to unleash my own <strike>5000</strike> 8000 word version upon the unsuspecting masses. This is one of the benefits of having your own blog, you see.</p>
<p>After much deliberation, I decided to make this loosely in the form of a list, despite my reservations against Buzzfeed-ification. To maintain the balance of the universe, I will forego numbering the list, which also allows me to emphasize that order does not matter. Some of the headings will be of the <em>&ldquo;Do this&rdquo;</em> form, calling you into action, while others will have more general and abstract titles. This is a conscious decision as not all advices are a call to action, some are a gist of learnings drawn from experiences. Moreover, this hopefully forces people to read through the whole thing and not just skim throught the titles. Contrary to what Twitter would have you believe, not everything can be condensed into 140 characters. Read the whole thing. You can make that the zeroeth advice. The others follow.</p>
<p><a name="list"></a></p>
<h2>Start Early</h2>
<p>Woody Allen said that 80% of success is showing up. I'd add that 90% of success is about showing up on time. In the world of computer science and Moore's Law, on time means early.</p>
<p>The best programmers start early. Jamie Zawinsky was already working for Peter Norvig on Lisp Machines right after high school, and Bill Gates was creating BASIC interpreters for fun before he reached puberty. The former went on the create what would become Mozilla Firefox and the latter hardly needs an introduction. This is just a small sample but it is enough to bring home the point. However, this is also very unfair on late starters. Zawinsky and Gates were born into privilege and had access to the resources and mindset they needed to take up programming from an early age. Most of us are not that fortunate, either financially or intellectually, so will we never be able to make up?</p>
<p>That is not how it works. Early simply means the earliest possible time, it is not a number or a threshold to live up to. Have you already programmed in school? Great, you are early. If you've not, you can be early by starting now. Not being early comprises of twiddling your thumbs while you have the resources you need to start. Since you are in college by now, the thumb twiddling needs to stop.</p>
<p>Starting out early affords you the time and opportunity to be wrong more than starting out late does. And learning to be a programmer is mostly about being wrong as many times as possible in as little time as possible. By being wrong more at first, you can be wrong less later. This means that when your noob friend is trying to figure out why his string has gibberish at the end, you can help him <code>null</code> terminate it and then insert a buffer overflow vulnerablity into his code for fun (don't do this). This is especially relevant in college and CS 101 type courses. If you started early and already know the basics of programming, you won't be banging your head against the desk trying to make sense of double indirection in your pointers class and can easily coast through your labs without much effort. This in turn affords you more time to learn the <em>other</em> stuff you'd rather be learning. This is a positive feedback loop and it's an easy one to start. This also applies for all of your CS career and not just for college. Since the CS ecosystem moves at such a rapid rate, being early to stuff will always keep you ahead of the median competiition, which is good for your career overall.</p>
<h2>Learn to Code (well)</h2>
<p>This should ideally go without saying but I have been surprised by how many people can't give a shit about learning to program <em>while</em> taking a CS course. It has never made sense to me, but I have accepted the fact that most people are in it for the job and not for computer science. However, if you <em>are</em> in it for computer science and not just for the job, then you can't do yourself a greater disservice than not learning to code.</p>
<p>College will run for 4 years. That is over 1200 days of time you have to hone your programming skills under little to no pressure. This is quite literally the time of your life and you'd thank heavens later in your career if you utilize it properly. If you are looking for a career in computer science, and unless you want to get into academia, you will be writing code for 40 hours a week. If you are going to be doing something for so much time, it only makes sense to try to be competent at it and inspite of all its criticisms, the college courses <em>do</em> provide enough practice to make you into a a decent programmer if you put in some of your own initiative.</p>
<p>Some courses are more relevant to this than the others. The ones I am talking about are <em>Data Structures</em>, <em>Algorithms</em> and <em>Compilers</em> amongst others. It is of utmost importance that you focus and if possible, master the curriculum of the first two courses I mentioned as they form the basis of computer science. It is important to note that you don't have to be a rockstar programmer who can code the Union Find algorithm from memory - actually, most rockstar programmers would not be able to do that anyways - but rather to have a good understanding of the basic data structures found in computer science and their functioning, uses and pitfalls. The usual suspects are <code>arrays</code>, <code>linked lists</code>, <code>binary search trees</code>, <code>heaps</code> and <code>hash tables</code>. Having a good grasp over these basic data structures gives you the foundation to understand more complex ones as these are the building blocks of more complex data structures quite often. Which leads me to the next point.</p>
<h2>Master the Basics</h2>
<p>You will invariably have to take a CS 101 course of some kind which teaches you basics of programming - conditionals, loops, expressions etc. A lot of times, people don't attach enough importance to these beginner courses are just coast through them, especially for people who already know how to program. Don't fall into that tarpit.</p>
<p>What CS 101 also teaches you (hopefully) is about data types, binary representation of data, two's complement form, <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">floating point arithmetic</a>, character arrays and strings, recursion, pointers and memory allocation amongst other things. All of these things are of utmost importance to understand if you want to become a good programmer. One of the differences between an average and a good programmer is how fast they can debug buffer overflow errors in their code.</p>
<p>For the script kiddies who have never programmed in anything but Python, it will be almost impossible to understand why <code>(3.0/4) == 0.75</code> does not return true all of the times. Don't turn into one of those people who can write a Django web app in a day but can't figure out why they have a memory leak and their 500MB Heroku Dyno is not able to handle the load of the grand total of their 3 dorm buddies logging in simultaneously. Think about it, would you trust a doctor who has no knowledge of human anatomy to prescribe you medicines based on what the pharma companies are pimping to everybody at that point of time? Then why should anybody trust a programmer who does not fully understand the anatomy of a computer program?</p>
<p>If possible, and if you are feeling particularly masochistic, you should also read about <a href="http://www.joelonsoftware.com/articles/Unicode.html">how Unicode strings are represented in memory</a> as it will probably save your job at least once in your life. <em>Especially</em> if you don't focus on mastering the basics.</p>
<h2>Programming Languages</h2>
<p>Programming Languages are the tools of our trade and a good programmer masters his tools. Mastering the chisel is a prerequisite to being a great craftsman, afterall. You should definitely try to become highly proficient in at least one programming language before you graduate from college. The choice of the language does not matter as long as it is a relatively modern and powerful language which is industrially relevant. Being modern means it is still being developed actively and has a new major version upgrade every few years. This is a sign that the community is invested in it and the language won't die anytime soon. The power of the language is something which we will touch on in a while. Being industrially relevant mitigates the risk that you are learning a skill which is not marketable.</p>
<p>Some languages are simply more powerful than the others, although this might not be initially evident. It is also possible to mistake a better syntax for more power. This is a common pitfall especially in the initial years when you don't really have any idea how a programming language works. Sometimes it is plainly evident, like higher level languages are more powerful than machine language. Sometimes the age is a factor, but not always. A language developed 40 years ago is likely to be limited by the technology available at that point of time. FORTRAN, developed in the 60s is not as powerful as Ruby, for instance, which came out in the 90s. But most of the times, the power of a language is in its features. Python looked like a more powerful language than Java because of its succinctness, but its lack of lexical scope meant that it was actually a <em>weaker</em> language implementation wise as you had to explicitly pass <code>self</code> to every method, something which is done automatically in most other languages.</p>
<p>But choosing the most powerful language is not always the optimal decision. LISP, developed in the 1950s is still probably one of the most powerful programming languages around because of the advanced concepts it introduced. But LISP is not a very marketable skill and is unlikely to fetch you many job offers. This does not mean that you should not learn LISP, on the contrary, you should, but probably not as your primary language.</p>
<p>Programming languages also come in different <em>paradigms</em>. Paradigm refers to the semantics of how they treat <em>data</em>, which is what is passed to your program and <em>functions</em>, which is what operates on the data. There are two major paradigms of programming languages based on whether they treat the data, or the functions as the primary building blocks of their programs. The former are called <em>imperative</em> languages and the latter are called <em>functional</em> languages. You will probably study about their properties and differences in more detail in your course, so it is useless to repeat all that here, but it is a good idea to learn at least one langauge emphasizing each paradigm. A good choice for an imperative language is <code>Java</code> or <code>Ruby</code> and a good choice for a functional language is <code>Clojure</code> or <code>Haskell</code>. <code>JavaScript</code> is a multi-paradigm langauge and can also be considered a good choice for either paradigm. <code>Scala</code> is a newer language which also combines multiple paradigms and has found widespread use in distributed and high availability systems like search engines. I'd also recommend that everybody learns the original <code>C</code> to understand how some lower level stuff works.</p>
<p>All in all, your choice of programming language should have little effect on anything, unless you take up something more esoteric like <code>Haskell</code> or LISP. Don't get me wrong, both of those are amazing languages and you'd gain a lot of insight by learning them, but you are less likely to find help and support locally. I don't recommend spending too much time learning <code>C++</code> or <code>PHP</code> as they are the source of constant pain and suffering for all who touch them.</p>
<p>Remember that all this is my personal opinion and there is no harm in learning LISP as your primary language if so is your inclination. My vote against <code>C++</code> and <code>PHP</code>, for instance, is purely because of my personal bias against them.</p>
<h2>Use a *NIX</h2>
<p>UNIX was the original hacker's operating system and has influenced the whole software industry heavily even though nobody uses pure *NIX systems anymore. The Unix philosophy is about making the system modular, with each part doing one thing and doing it extremely well. This lead to the development of some iconic tools which are still in use today, almost 50 years later, like <code>cat</code>, which simply prints out the contents of some file onto the screen, <code>wc</code> which counts the number of characters, lines and words and <code>grep</code>, which searches a file for a match against some given pattern. Separately, all these tools have limited scope, but the beauty is in combining them using Unix <code>pipes</code> so that you can find the number of occurences of your name in all the files that you have. This is obviously a less useful example than what is actually possible, but hopefully you get the idea. If you want a more impressive example then you can also find duplicate files by <em>content</em> and not just by name on your system and delete the redundant ones.</p>
<p>The easiest to use *NIX like system nowadays is Linux. I suggest you start with a distribution of <a href="http://ubuntu.com"><em>Ubuntu</em></a> - which in turn is a distribution of Debian - but let us leave that for another day - as it has a good release cycle in which the long term support releases recieve security updates for 5 years and are reasonably stable. You don't have to worry about your preference for how Ubuntu looks by default since it is a Linux and it can be completely customized to look however you want it to. If you've never used anything other than Windows, Ubuntu will require less of a leap of faith than you are afraid of. You can dual boot Ubuntu with Windows without breaking anything so that you can have the best of both worlds (i.e. you can still play your favourite games on Windows).</p>
<p>The main reason to use Linux is because the world runs on Linux. I think over 80% of the websites run on Linux and any half-competent programmer will be using some version of a NIX as their daily driver. This does not mean that there is anything <em>wrong</em> with Windows, which is a perfectly fine operating system. But over 3 generations of hackers have grown up using <em>NIXes and they have written their best software to work on </em>NIXes and so Windows only gets half an afterthought when it comes to support for the platform. You will find yourself pulling your hair out trying to make things work exactly as they are defined in the <em>manual</em> because you forgot to read the fineprint which said that Windows was not officially supported. Save yourself the trouble; and the hair.</p>
<p>Another great reason is <code>bash</code>. <code>bash</code> is a command line interpreter, or as they are generally called, a <em>shell</em>. It is a way of giving commands to the operating system. Windows has the <code>PowerShell</code> as the equivalent, and no, <code>cmd</code> does not count. <code>bash</code> understands all of the *NIX system commands and also has a scripting language so that you can write small programs which can make it do stuff, like normal programs. But you don't have to do that. Just getting comfortable with the 20 most common <code>bash</code> commands will take you a long way. Of course, that requires that you actually use it in the first place, but if you do, you can impress all your noob friends with your incredible UNIX hackery.</p>
<h2>Code for Fun</h2>
<p>I meant to write two different subtopics to cover this - <em>Contribute to Open Source</em> and <em>Do Personal Projects</em> but I decided both of those things are means to the same end and so it makes more sense to have them under one topic. But if you'd rather have them separately, then just get your own blog.</p>
<p>I'll make the controversial statement that if you don't code for yourself, you'll never become a great programmer. Sure, you can just get away with doing what the coursework requires you to do and get a decent job and live a comfortable life but you will never become a great programmer. You will be another one of the thousands that the education system just prints out every year. I don't know about you, but the thought of being generic makes me uncomfortable.</p>
<p>Don't be generic. The best programmers that I know of are prolific coders. They create things for themselves. Scratching your own itch is a great way of actually getting things done and learning new things in the process because the initial goal keeps you motivated throughout the course of the work. Want to keep track of movies you watch? Or the TV Shows you follow? Does your music collection lack metadata? Do you want to intelligently suggest new movies to yourself based on your liking? All these are very real problems an average college student faces and all of these make some great itches to scratch as they are easy but non trivial problems to solve using code.</p>
<p>The itch doesn't have to be big. You don't need to create a whole new web browser just because you think Chrome eats too much memory. But you can probably write an extension which makes it eat less memory. An even better way of accumulating projects is by using your course projects to actually make something serious/cool instead of another library management system. Not that there is anything wrong with library management systems, but the world probably has more library management systemes than it has individual libraries and the it won't stop spinning if there is one fewer. But if you make a program which correctly fetches metadata for, and organizes your music collection, you are more likely to find people who have a use for it and who will be willing to send you internet memes, or cute cat pictures or at times money in return for your work. And as we all know, there are very few things in life better than cute cat pictures.</p>
<p>Then there are open source projects. They allow you to experience how software development happens at scale without taking on any responsibility at all. Making a meaningful contribution to an open source project also gives you that saint like feeling. Contributing to an existing open source project is very different from making your own project from scratch. Most of the time you will working with existing code, which means that you will have to read what <em>other</em> people have written before you can start writing code yourself. This is a much more daunting task than it sounds and it takes getting used to. However, once you are comfortable doing it, it will be a huge asset. It is worth reminding yourself that good programmers write good code, but great programmers take good code and make it better.</p>
<p>Make an aim that you will meaningfully contribute to at least one open source project before you graduate and that you will have at least one non trivial project for each year. You will end up with 4-5 different and interesting things to put on your resume by the time you are done with college, and more importantly, you will have <em>experience</em> to share with others.</p>
<h2>Learn Some Maths</h2>
<p>It is still a widespread notion that Computer Science is a branch of mathematics in its essence. And it is not completely false. Maths permeates most computer science fields and is used to prove important theoretical concepts and build intuition to solve hard problems. However, you don't need to be a maths wizard to be a great programmer. I am a median mathematician at best, but I am a much better programmer. Most of the time, a good grasp over high school level maths suffices. But if you are curious and like maths, there is no reason not to pursue more theoretical concepts in depth.</p>
<p>The areas most relevant to computer science are Discrete Mathematics and Linear Algebra along with some rudimentary Statistics. Your college courses will cover some of these areas but without any apparent co-relation to computer science and it will be difficult to keep yourself motivated enough to understand abstract mathematical concepts without some use cases to back their practicality. So I recommend that you read two different books by yourself, outside of class to build up the mathematical intuition necessary to succeed in CS. The first book I recommend is <a href="https://en.wikipedia.org/wiki/Concrete_Mathematics"><em>Concrete Mathematics</em></a> by Donald Knuth et al. Now, Knuth is a pioneer of computer science and anything he writes is automatically worth reading multiple times, but this particular book is gold. I suggest you study atleast the first half of the book in the first year itself. The second book I'd recommend is <a href="http://greenteapress.com/thinkstats/"><em>Think Stats - Probability and Statistics for Programmers</em></a> which is freely available and is a great resource on understanding enough statistics to be dangerous (and not make a fool of yourself).</p>
<p>I don't have any recommendations for linear algebra but it is an important topic to grasp if you want to get into the Machine Learning side of things, as you will ultimately discover that us humans have somehow foolishly convinced ourselves that the best representation of any sufficiently large set of data is in the form of a matrix.</p>
<h2>Get Programming Internships</h2>
<p>Get yourself internships that involve a programming job. This, of course, is only applicable to you if you want to have a career as a software developer. I have a friend who does not want such a career and so his time is best spent doing more marketing internships because that is what he wants to do. The point is that you should get internships relevant to the area you see yourself in 5 years time.</p>
<p>As a budding developer, you will do yourself a huge disservice by spending your summers doing anything but writing code. You will have three summers in total, excluding the last year. The first one of those will go by because you won't be qualified enough (more often than not) to land any kind of valuable internship. You should do absolutely everything in your power to spend the rest of the two summers working as a developer somewhere. Don't take up jobs just for the certificate where you won't be required or expected to do any real work. You will end up with nothing to show for your 2 months and any self-respecting developer will see right through your bogus internship experience as soon as you put it on your resume.</p>
<p>The aim of an internship is two fold. The first aim is for you to learn as much as possible about work in the <em>real</em> world. This involves working as a part of a team, contributing code which is released for use by actual people, managing tradeoffs between technologies etc. The second aim is for you to learn how to be a better developer by seeking out mentors from amongst your seniors on the job. They can be anybody, but forging a good relation with a mentor will help you learn more in two months than you might have learnt in two years at college.</p>
<p>Ideally, one of your internships should be at an established company and another one at an up and coming startup. This allows you to get a taste of both kinds of workplaces as they are very different from each other more often than not. Beware not to take up an internship solely based on the name of the company, though. You want to work at a place which has a great engineering culture, not a great bureaucratic culture.</p>
<p>Sometimes you can substitute one summer of internship with a prestigious programme like the Google Summer of Code, which will provide you a more mentored experience to software development and will give you a chance to contribute to an existing open source project, helping you kill two birds at once. A research internship with a professor at a reputed school is also great <em>if</em> you are genuinely interested in the field. Research conducted during the undergrad years also goes a long way in helping with admissions to grad schools later on.</p>
<p>The bottom line is that you should not at any cost graduate from college without at least one internship under your belt.</p>
<h2>Read As Much As Possible</h2>
<p>This might <em>seem</em> weird at first, because what the heck has reading got to do with successfully navigating through college? But it does! You come to college first and foremost to get an <em>education</em>, and the college does not guarantee to give you <em>all</em> of it by itself. Majority of your education at college will be self provided, and reading more books is one sure shot way of ensuring you get yourself a good one.</p>
<p>I say books, but I don't mean pulp fiction by Chetan Bhagat et al. For the love of god, avoid Indian authors as much as possible and read as many classics as you can. There are multiple lists of greatest books ever written which you can peruse and mark out between 20 - 50 of them to read in the 4 years you will spend at college. They don't have to be all fiction. Non fiction titles like Niall Ferguson's <em>The Ascent of Money</em> are great and informative reads and should definitely make up a part of your reading material.</p>
<p>It is also beneficial to read technical books as much as possible. Some of the timeless titles in computer science are <em>Code Complete</em>, <em>Programming Pearls</em> and <em>The Pragmatic Programmer</em>. I sincerely believe that <em>Programming Pearls</em> should be required reading for all computer science undergraduates.</p>
<p>But your reading lists doesn't have to be books at all. Scientific papers, technical blog posts, long form essays are all fair game as long as they are relevant and not written by Chetan Bhagat. It is believed that people who devour books by Chetan Bhagat grow up to become Donald Trump sympathizers. Please save yourself the embarrassment and don't read that guy. Also save yourself the trouble of reading (auto)biographies. They provide good entertainment at times, but somebody else's life experiences are going to be of little to no value to you at this stage in life unless it particularly relates to your situation. The inspiring parts of anyone's life can be condensed into a short article which wastes much less amount of your time. But obviously, don't let me stop you from reading the third Steve Jobs biography if that floats your boat.</p>
<h2>Find What You Like</h2>
<p>Computer Science is a huge field. It has so many different sub divisions and partitions that even if you <em>know</em> for sure that you want a career in CS, you might not know exactly what it is that you want to be doing. The undergrad degree gives you an opportunity to resolve such doubts, you should take it up with both hands, and probably a foot, and crush it.</p>
<p>The four year degree will teach you a little about a lot of things, and it is very possible that you will come out feeling dissatisfied with the education that you received for your money. This makes it imperative that you explore all fields that seem interesting to you and decide which one you want to pursue. Machine Learning, Natural Language Processing, Computer Graphics, Networking, Human Computer Interaction, Cryptography and Distributed Systems are a few names to set you off on the search. There are many more, and you should explore everything. Knowing exactly what you like and want to do is a huge asset and gives you the confidence to go get it.</p>
<p>It is okay if you discover that you don't like anything, or if you discover that you simply want to build web applications all your life. All such pursuits are equally noble and the world needs great web application designers as much as they need great cryptographers. The challenge is in becoming great at what you want to be, and the first step to that is knowing what you want to be.</p>
<h2>Don't Ignore Academics</h2>
<p>This is the easiest crime to commit. Not studying is easier than studying, and that leads to poor grades, which leads to more of not studying, which in turn leads to more of those poor grades. Eventually you turn into a bitter person who thinks that the education system is a farce and you don't need an education anyways since they didn't teach you anything practical at school. Remember that positive feedback loop that comes from starting early? This is the opposite. This is the negative feedback loop which comes from ignoring your academics.</p>
<p>Don't get into the trap of believing that your CGPA does not matter. Like Joel Spolsky has written, your CGPA is the one number in which your performance over multiple years of tests, assignments, lab exams and the opinions of all your teachers is condensed in. It is used as a criterion to evaluate you and it will continue to be used, and the best you can do about it is to not make it drop so low that it is unredeemable. I know, it is probably unfair, you probably did not like the courses, or you had to miss some tests due to sickness or you were busy doing more important development work. But life is unfair and there will always be somebody who did what all you did <em>and</em> has a stellar CGPA, and nine out of ten people will take the person with the stellar CGPA, all other things considered equal.</p>
<p>Don't get disheartened at this. In most cases, unless your CGPA is over 9.5, a CGPA over 8 is fine and will keep you in the same bucket as somebody with an 8.95. At some points though, you <em>will</em> be rejected because of your CGPA, which is completely unfair, but the onus is on you to minimize the number of occassions that happens. Another good thing is that CGPA will matter less and less as your career progresses. However, you still need it to get your foot inside the door.</p>
<p>Good academic performance also keeps you in the good books of the professors. This can come in extremely handy when you need recommendations from them. Always remember to interact with your professors as much as honestly possible. If you are attentive in class, you are bound to get some questions. Pitching these questions to your professor after class is a good way to build up rapport with them. However, be careful to not to pester them with irrelevant questions just to get their attention. Most professors are smart people and can see through that easily. They are also extremely busy and might not like your constant intervention in their free time. There is a balance you need to maintain and it will take some amount of thinking to be done perfectly, but doing it right will almost always pay off well in the end.</p>
<h2>Fraternize</h2>
<p>Join clubs, both technical, and if you like, non-technical. This will help you meet like minded people and also teach you things about resource management and team work. But it is the people that ultimately matter, as they will form your personal and professional network for a long time to come, so it is very important to meet and keep up with the right people in your campus.</p>
<p>Technical clubs provide an easy way to find such people as the more technically inclined folk flock to these things more often than not. Being around smart people will help you grow tremendously as you can always find somebody to learn new things from and it also helps you hone your social skills, which will become more and more important as your career progresses. Technical clubs also provide a small glimpse into how any non-trivial organization functions, and many have their own finance and sponsorship departments. Having a good knowledge of how these things work is also an asset and will probably teach you a thing or two about economics and marketing.</p>
<p>Non-technical clubs are a great way to hone your creativity and meet interesting people who do not share your technical mindset and will give you a well deserved release from the technical echo chamber that you are going to trap yourself in eventually. It is very possible that you are a great sportsperson or a great singer. Most colleges will have dedicated societies for such things and can provide you with great means to unwind or simply have fun once in a while. I am, of course, assuming that even if you are a great singer, your primary interest lies in computer science.</p>
<p>It is important to keep in mind not to join too many clubs on campus as their activities can suck in all of your free time, which you're much better off spending on some personal project or open source contributions. Prioritizing your time is extremely important.</p>
<h2>Maintain Your Own Website/server</h2>
<p>I was on the fence on whether this should be required but there is net gain to achieve from being able to administer a server or at least have your own site. Getting a site consists of two steps, getting a domain name and then pointing it to a server where you have your files. Getting a domain is so easy and cheap nowadays that you don't have to think before doing it. You will probably spend more money on Coca-Cola in one year than you will on your domain name. There is hardly any reason not to get one.</p>
<p>Getting a server is still expensive enough that most students won't afford it, but with the advent of static site hosts, the need for a server has been eliminated. At the very least though, you should know how to FTP your files to your host and how to point your domain to the correct nameservers. This process is bound to teach you some rudimentary stuff about how web servers and domain names work and will end up getting you a home on the interwebs. What is there to lose?</p>
<p>More recently though, it has become a norm to have at least a landing page with personal information, or links to various social profiles. This gives you an easy link to pass around when somebody asks for your info, and also makes it easier for potential employers to find you. Moreover, it also gives you the chance to learn basic HTML and CSS to setup your page, which I consider to be required knowledge for any developer worth their salt.</p>
<h2>Learn the Tools of the Trade</h2>
<p>Which means learn how to use a superior text editor, a debugger and a version control system. By a superior text editor, I mean either Vim or Emacs. I personally prefer Emacs but objectively more people use Vim because it comes pre installed on most *NIXes. Both are great and customizable text editors which you can keep tuning to your satisfaction. All other text editors are objectively inferior. (Sorry Sublime Text fans, but truth hurts).</p>
<p>The debugger du jour is <code>gdb</code>, which stands for the GNU Debugger. It has the capability of being attached to any running process so you can debug programs written in almost any language with it. Although the learning curve involved is a bit steep, it does pay off in the long run and is definitely worth learning about.</p>
<p>The version control system du jour is <code>Git</code> and it is not going anywhere, primarily because it has all the features of long lasting software - it is esoteric, hard to use, written in pure C and interacts well with *NIX utilities. Linus Torvalds has somehow managed to make two pieces of omnipresent software in one lifetime and it is worth your time to learn both of them.</p>
<p>If you use a superior text editor, it will probably have some integration with both <code>gdb</code> and <code>Git</code> so that you won't ever have to leave the comfort of your text editor to do any development work. Emacs also has a mail reader and web browser built in if you are so inclined. The point I am trying to make is that once you start integrating all your tools, you end up with an integrated development environment, or IDE. The term IDE has been popularized by the Java ecosystem since the language required some excellent tooling to assist it, and the community delivered (see IntelliJ IDEA). If you are programming in a language like Java or C#, it is probably wise to use a dedicated IDE for it instead of your superior text editor since the IDEs have a better level of integration with language features, especially autocomplete and automatic builds. For dynamic languages like Ruby or Python, a text editor is more than enough.</p>
<p>It should go without mentioning but please get yourself a professional looking email address. The <code>coolfootballer96@hotmail.com</code> email you thought was <em>cool</em> back in 2005 is not cool and will actively stop you from getting opportunities as people will judge you without fail when they look at that address. The best email address is one hosted on your own domain. However, a sober email address with not much more than your name in it will also do. Academic emails are almost always better than a gmail address as it provides you some credibility.</p>
<p>Which brings me to the next point: learn to write proper English. As a developer, you will be paid to churn out text, it is your responsibility that you churn out good text, and not embroil yourself in scandals involving SMS language. Those are the things <a href="http://thedailywtf.com/">the Daily WTF</a> stories are made of. Emojis are fine when used in moderation and non standard abbreviations should be avoided like the plague. Nothing will piss off your coworker more than having to reply to your mail just ask what <em>&ldquo;IDKFS&rdquo;</em> means. Any time you thought you saved by abbreviating of your own free will is going to be reclaimed by such unnecessary back and forth communication.</p>
<h2>Recommended Reading</h2>
<p>I am hardly the authority when it comes to career advice and it is much easier for me to point you to the more accomplished personalities who have much better things to say about being a successful CS student. So I will link you to <a href="http://www.joelonsoftware.com/articles/CollegeAdvice.html">Joel Spolsky</a>, <a href="http://matt.might.net/articles/college-tips/">Matt Might</a> and <a href="http://www.paulgraham.com/college.html">Paul Graham</a> and be done with it.</p>
<h2>Conclusion</h2>
<p>This turned out to be a much longer piece than I had anticipated but I hope I have filled it with some value worth your time. This is obviously heavily coloured by my own experiences and learnings from those experiences. But that is what you get when you ask for free advice: other people's opinions. You have no right to complain. I will keep updating this as I keep getting new ideas. I wrote this to be the one true source I can send people who ask me for advice, so it will very much be a living document for some time to come. As you can see, there are no comments on my blog, which is another advantage of having your own blog. If you want to tell me how much you hated this piece and how worthless my opinion is, <a href="https://twitter.com/thepawandubey">shoot me a tweet</a>, or an <a href="mailto:pawandubey@outlook.com">email</a>. I will be sure to include any interesting pieces of opinion that come my way, unmoderated.</p>

				<hr>
<span style="font-family: 'Raleway','Open Sans', sans-serif; font-size: small;">Share this post on </span>:<ul class="share-buttons">
  <li><a href="https://www.facebook.com/sharer/sharer.php?u=http://blog.pawandubey.com/advice-for-cs-freshmen/&t=Some Advice for CS Freshmen" target="_blank" title="Share on Facebook"><i class="fa fa-facebook-square fa-lg"></i></a></li>
  <li><a href="https://twitter.com/intent/tweet?source=http://blog.pawandubey.com/advice-for-cs-freshmen/&text=Some Advice for CS Freshmen: http://blog.pawandubey.com/advice-for-cs-freshmen/&via=thepawandubey" target="_blank" title="Tweet"><i class="fa fa-twitter-square fa-lg"></i></a></li>
  <li><a href="https://plus.google.com/share?url=http://blog.pawandubey.com/advice-for-cs-freshmen/" target="_blank" title="Share on Google+"><i class="fa fa-google-plus-square fa-lg"></i></a></li>
</ul>
                <hr>
<span class="tags" style="font-family: 'Raleway','Open Sans', sans-serif; font-size: small;">Posted under <a href="http://blog.pawandubey.com/tags/code" class="tag"> code</a></li> <a href="http://blog.pawandubey.com/tags/cs" class="tag"> cs</a></li> <a href="http://blog.pawandubey.com/tags/college" class="tag"> college</a></li></span>
                
            </div>
        </div>
    </div>
</article>

<hr>

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="http://blog.pawandubey.com/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/thepawandubey">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="https://github.com/pawandubey">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://plus.google.com/+PawanDubeyK">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; <a href="http://pawandubey.com">Pawan Dubey</a>. Made with <span class="fa fa-heart-o"></span> and <a href ="https://github.com/pawandubey/griffin">Griffin</a></p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="http://blog.pawandubey.com/assets/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="http://blog.pawandubey.com/assets/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="http://blog.pawandubey.com/assets/js/clean-blog.min.js"></script>

<!--Highlight.js-->
<script>hljs.initHighlightingOnLoad();</script>


</body>

</html>
